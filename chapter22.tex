\newpage
\chapter{Символьный ввод-вывод}

\section{Символьный ввод-вывод и соответствующие декораторы}

В предыдущих темах мы ознакомились с понятиями библиотек и потоков ввода-вывода, их классами и работой с ними, а также байтовыми классами и декораторами ввода-вывода.

В этой теме речь пойдёт о схожем классе — \textbf{символьном вводе-выводе}. В отличие от байтового, оперирующего только последовательностями байтов и байтовыми потоками, символьный предполагает описание и управление \textbf{символьными последовательностями — строками}. Для этой цели используется отдельный вид потоков — \textbf{символьный поток}.

Символьный поток также разделяется на две категории — поток ввода и вывода, им соответствуют абстрактные классы \verb|Reader| и \verb|Writer| соответственно. Они позволяют создавать и использовать множество дочерних классов, используемых для управления некоторой категории строковых данных.

Для потоков ввода \verb|Reader| является родителем для следующих наиболее распространённых классов-декораторов:

\begin{enumerate}
    \item \verb|FileReader| — позволяет связать символьный файл и поток ввода;
    \item \verb|BufferedReader| — использует буферизованный поток ввода символов (используется для сокращения количества обращений к носителю данных);
    \item \verb|CharArrayReader| — считывает данные из массива символов;
    \item \verb|FilterReader| — использует отфильтрованный некоторым(и) правилом(ами) поток ввода символов.
\end{enumerate}

Также этот родительский абстрактный класс содержит несколько методов, из которых мы выделим основные:

\begin{enumerate}
    \item \verb|int read()| — возвращает представление очередного доступного символа во входном потоке в виде целого числа;
    \item \verb|int read(char[] buffer)| — пытается прочесть максимум \verb|buffer.length| символов из входного потока в массив \verb|buffer|. Возвращает количество символов, в действительности прочитанных из потока;
    \item \verb|int read(char[] buffer, int offset, int length)| - пытается прочесть максимум \verb|length| символов, расположив их в массиве \verb|buffer|, начиная с элемента \verb|offset|. Возвращает количество реально прочитанных символов;
    \item \verb|close()| – метод закрывает поток.
\end{enumerate}

Для потоков вывода \verb|Writer| классы-декораторы в целом схожи, различие лишь в изменении части сигнатуры \verb|Reader| на \verb|Writer|. ЧТо же касается методов, то у \verb|Writer| они отличны от \verb|Reader|:

\begin{enumerate}
    \item \verb|void write(int c)| – записывает один символ в поток;
    \item \verb|void write(char[] buffer)| – записывает массив символов в поток;
    \item \verb|void write(char[] buffer, int offset, int length)| – записывает в поток подмассив символов длиной \verb|length|, начиная с позиции \verb|offset|;
    \item \verb|void write(String aString)| – записывает строку в поток;
    \item \verb|void write(String aString, int offset, int length)| – записывает в поток подстроку символов длиной \verb|length|, начиная с позиции \verb|offset|.
\end{enumerate}

\section{Стандартные потоки ввода-вывода}

Все языки программирования обеспечивают поддержку стандартного ввода/вывода, где программа пользователя может произвести ввод посредством клавиатуры и осуществить вывод на экран компьютера. Если вы знакомы с языками программирования C либо C++, вам должны быть известны три стандартных устройства \verb|STDIN|, \verb|STDOUT| и \verb|STDERR|. Аналогичным образом, Java предоставляет следующие три стандартных потока:

\begin{enumerate}
    \item \textbf{Стандартный ввод} (\verb|STDIN|) – используется для перевода данных в программу пользователя, клавиатура обычно используется в качестве стандартного потока ввода, представленного в виде \verb|System.in|;
    \item \textbf{Стандартный вывод} (\verb|STDOUT|) – производится для вывода данных, полученных в программе пользователя, и обычно экран компьютера используется в качестве стандартного потока вывода, представленного в виде \verb|System.out|;
    \item \textbf{Стандартная ошибка} (\verb|STDERR|) – используется для вывода данных об ошибке, полученной в программе пользователя, чаще всего экран компьютера служит в качестве стандартного потока сообщений об ошибках, представленного в виде \verb|System.err|.
\end{enumerate}

\section{Взаимодействие со стандартными потоками при помощи объектов классов символьного ввода-вывода. Класс Scanner}

Заметим, что с помощью перечисленных ранее классов символьного ввода-вывода можно также передавать данные через консоль ввода-вывода ошибок — причём как прямо на консоль, так и опосредовано, через файлы/фильтры/пр. Рассмотрим следующий пример:

\begin{lstlisting}
import java.io.*;
 
public class Program {
 
    public static void main(String[] args) {
         
        try(BufferedReader br = new BufferedReader (new InputStreamReader(System.in)); 
            BufferedWriter bw = new BufferedWriter(new FileWriter("notes5.txt")))
        {
            String text;
            while(!(text=br.readLine()).equals("ESC")){
                  
                bw.write(text + "\n");
                bw.flush();
            }
        }
        catch(IOException ex){
              
            System.out.println(ex.getMessage());
        } 
    }   
}
\end{lstlisting}

Здесь мы определяем два буферных потока ввода-вывода — \verb|br| и \verb|bw|. Каждый из них при этом использует различный источник: так, поток ввода использует стандартный поток ввода \verb|System.in| вместе с байтовым \verb|InputStreamReader| для получения и передачи байтов информации, полученных через консоль ввода. В свою очередь поток вывода использует файловый поток вывода, связанный с файлом notes5.txt.

Здесь считывается некоторая строка текста, а затем проверяется, не равна ли она строке "ESC" — указателю того, что приём данных должен завершиться. Если строки не равны, то полученная строка сначала передаётся в поток вывода \verb|bw| вместе с \verb|\n| — символом перехода на новую строку — а затем поток очищается, передавая информацию прямо в файл.

Как вы могли заметить, конструкция связи между стандартным а и символьным потоками ввода довольна громоздка, поэтому встаёт вопрос об упрощении получения данных из консоли. Для этого как раз и используется вспомогательный класс \verb|Scanner|, который позволяет напрямую, без помощи байтовых потоков сразу использовать \verb|System.in|. Рассмотрим ещё один пример:

\begin{lstlisting}
import java.util.Scanner;
 
public class Program {
   
    public static void main(String[] args) {
           
        Scanner in = new Scanner(System.in);
        System.out.print("Input name: ");
        String name = in.nextLine();
        System.out.print("Input age: ");
        int age = in.nextInt();
        System.out.print("Input height: ");
        float height = in.nextFloat();
        System.out.printf("Name: %s  Age: %d  Height: %.2f \n", name, age, height);
        in.close();
    }
}
\end{lstlisting}

Здесь мы создаём объект класса \verb|Scanner| под названием \verb|in|, через который мы можем передавать введённые через консоль данные. Сам класс содержит несколько методов, позволяющих это сделать:

\begin{enumerate}
    \item \verb|next()| — считывает введенную строку до первого пробела;
    \item \verb|nextLine()| — считывает всю введенную строку;
    \item \verb|nextInt()| — считывает введенное число целочисленного типа \verb|int|;
    \item \verb|nextDouble()| — считывает введенное число вещественного типа \verb|double|;
    \item \verb|nextBoolean()| — считывает значение булева типа \verb|boolean|;
    \item \verb|nextByte()| — считывает введенное число типа \verb|byte|;
    \item \verb|nextFloat()| — считывает введенное число типа \verb|float|;
    \item \verb|nextShort()| — считывает введенное число \verb|short|;
\end{enumerate}

\label{pages_total}
